# HTTP 相关问题

包括目录：

* HTTPS
* Cookie
* HTTP/2

## HTTPS

HTTPS 主要涉及的知识点是

* 对称加密算法（效率高，但需要先传递秘钥）
* 非对称加密算法（效率低，但更安全）
* 每个端有3个KEY： 公钥，私钥，和对称的秘钥
* 客户端发信息给服务器时用的对称秘钥 和 服务器发信息给客户端时用的对称秘钥 是两个秘钥
* 使用非对称算法来传递两个秘钥，之后使用对称算法以及两个秘钥进行后续通信

详细内容可以查看[网络安全](./网络安全.md)，中间有详述。

## Cookie

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)

Cookie 一开始是为了存储用户状态而出现的。它使得无状态的 HTTP 协议可以记录用户信息，从而让服务器得知哪两个请求是同一个客户端发过来的，也就有了状态。后来随着业务发展越来越多的数据存到了 Cookie 中，但每次请求都需要带上 Cookie，所以很大的 Cookie 不利于通信效率，会有浪费。现在有了 localStorage 和 indexDB 之后，Cookie 重新又变小了。

### 创建 Cookie - Set-Cookie

当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 `Set-Cookie` 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

服务器使用 Set-Cookie 响应头部向用户代理（一般是浏览器）发送Cookie信息，要求浏览器保存这个 Cookie。一个简单的Cookie可能像这样：

```
Set-Cookie: <cookie名>=<cookie值>
```

之后浏览器保存了这个值之后，在以后的每次请求都会带上这个值。

### Cookie 的有效期

Cookie 按有效期分类，可以分成两种：

1. 会话性：不写 `expires` 或者 `max-age`，表示一次会话有效。关闭浏览器之后再打开，这个 Cookie 就不存在了。不过现代浏览器增加了“恢复会话”功能，所以可能下次打开依然还在。

2. 持久性：有 `expires` 或者 `max-age`，表示在这个时间以前一直保存着。这个时间是**浏览器时间**，而不是服务器时间。

### Cookie 的 Secure 和 HttpOnly

标记为 `Secure` 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 `Secure` 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，`Secure` 标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用 Cookie 的 `Secure` 标记。

为避免跨域脚本 (XSS) 攻击，通过 JavaScript 的 `document.cookie` API **无法访问**带有 HttpOnly 标记的 Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。

```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

### Cookie 的作用域

`Domain` 和 `Path` 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。

`Domain` 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机 **（不包含子域名）**。如果指定了Domain，则一般包含子域名。

例如，如果设置 `Domain=mozilla.org`，则 Cookie 也包含在子域名中（如 `developer.mozilla.org`）。

`Path` 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 `%x2F` ("/") 作为路径分隔符，**子路径也会被匹配**。

例如，设置 `Path=/docs`，则以下地址都会匹配：

```
/docs
/docs/Web/
/docs/Web/HTTP
```

## HTTP/2

HTTP/2 的主要目标是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 HTTP 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。

为了实现 HTTP 工作组设定的性能目标，HTTP/2 引入了一个新的**二进制分帧层**，该层无法与之前的 HTTP/1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2。即便如此，除非我们在实现网络服务器（或自定义客户端），需要使用原始的 TCP 套接字，否则您很可能注意不到任何区别：所有新的低级分帧由客户端和服务器为您执行。 可观察到的唯一区别将是性能的提升和请求优先级、流控制与服务器推送等新功能的出现。

HTTP/2 的基础是 Google 最早在 2009 年提出的实验协议 SPDY，之后两者逐渐融合，直到 2015 年 HTTP/2 正式发布。

HTTP/2 和 1 相比，差异有：

1. HTTP/1 需要使用多个连接才能实现并发和缩短延迟，而 HTTP/2 通过支持标头字段压缩和在同一连接上进行多个并发交换（**双向&并发通讯**），让应用更有效地利用网络资源，减少感知的延迟时间。简单来说，**可以减少连接数**，增加连接的持续时间，增加对网络容量的利用率。

2. HTTP/2 允许为请求**设置优先级**（1-256），进一步提升性能。

3. **二进制分帧层**。客户端和服务端把传输的消息分割成更小的帧（之前是用换行符分割的纯文本，也就是不压缩的），再使用新的二进制编码机制进行编码。这个变更对应用透明。

4. 利用二进制分帧层，因为每个帧有编号，因此客户端和服务器可以同时在一个连接内交错发送，互不影响。**这是 HTTP/2 的核心基础**，这样就允许并行发送多个请求或者响应，一些 HTTP/1 的常用优化策略也可以淘汰了，例如雪碧图。

5. 既然可以对一个连接进行复用，那么理想情况就是一个来源一个连接。同一个来源的通讯反复使用这一个连接就够了。

6. 作为服务器来说，接到一个请求之后，可以发送多个响应（尽管可能客户端并没有请求他们）。这主要用在请求 HTML 和相关静态资源（JS, CSS, 图片等）上，因为服务器知道 HTML 中包含哪些必要的资源，就不必等客户端解析后再行请求。这种推送的数据流叫做 PUSH_PROMISE。客户端也可以拒绝这种推送，比如资源已经在缓存中存在。拒绝通过一个叫做 REST_STREAM 帧实现。
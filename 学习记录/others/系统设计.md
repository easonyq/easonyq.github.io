# 系统设计

## 前后端架构概览

```
前端 (HTML CSS JS)

    HTTP / web socket

Nginx / Load Balance

    HTTP

Web Server (nodejs, Java, PHP)

    RPC / SOA

Application Server (MQ, 区分PC/Mobile)

    REDIS

DB / ES / Deamon
```

## DB

CAP原则：任何DB至多只能满足CAP的其中之二。

C：一致性
A：**待补充**
P：分布可用性

### RDB

以 MySQL 为代表的传统 DB，业界大规模使用。需要注意的概念是

1. 分表

    当一个表很大了之后，需要分拆。分拆原则有很多，最简单的是平均分配，比如取模，分段等等，各有优劣。

    还有一种分发叫做纵向分割，即一条记录某几列在这个表，某几列在另外一个表。刚才那种叫横向分表，比较常用。

2. 分库

    虽然分表能解决容量过大影响性能的问题，但不能解决吞吐量的问题，因为吞吐量限制是以数据库为单位，而不是以表为单位。

    例如一个库有10张表，如果只想针对用户表进行吞吐量的提升，可以牺牲其他9张表的吞吐量，这实际是做不到的。

    那么解决方案就是把用户表单独成一个库。

### NoSQL

以 Mongo 为代表，它的优势是没有固定的 schema，因此可以比较灵活的存取。

比较新的叫 CouchDB。

**待补充**

### 列式存储

以 HBase 为代表。

**待补充**

### New SQL

Cassander， LSM算法

**待补充**

### 缓存

Redis

**待补充**

## ES

Elastic Search，可以理解为后端的搜索引擎，主要用于搜索日志。

基于 field，通过倒排查询到数据。

**待补充**

## Deamon

一些守护进程，多用于定期清理业务数据，删除日志，推送数据等。是 Application Server 的一部分，但逻辑上可以独立。

## 消息队列 (MQ)

假设A调用B，同步调用方式下，A调用B的API（多用RPC或者HTTP），B同步返回。

如果想使用异步方式提升效率，那么A必须给B留一个回调API，这样B完成后，通过API返回结果。这个类似于前端回调。不过这样会导致A和B互相依赖。

更好的方式是构造一个消息中间层（集群），收集A的调用信息，调用B后再把结果返回给A，解开了A和B的依赖关系，同时也可以支持服务的添加和删除。

Kafka 是实现消息队列的常用架构。

**待补充**

## 前端

mobx
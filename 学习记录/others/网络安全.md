# 网络安全

## HTTPS

HTTPS 总共涉及到3个方面，分别是：
1. 客户端，即浏览器或者客户端程序（如APP, PC上的应用程序等）
2. 服务端，即支持 HTTPS 的服务器
3. CA 机构，即 HTTPS 证书签发和管理机构

HTTPS 要解决的是两个问题：
1. 确认用户访问的网站就是真实的网站，而不是仿冒或者钓鱼网站
2. 保证传输的私密性和完整性，防止通过网络抓包来窃取和篡改数据包的内容，如添加广告。

HTTPS 工作流程，基本分为三个阶段：

1. 认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。

2. 协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，和用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。

3. 加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。

总结：
1. 每次会话，客户端先随机生成公私钥。之后客户端和服务端都会生成一个会话秘钥。所以实际上两端都有公钥，私钥和会话秘钥三种KEY。
2. 会话秘钥都需要传递给对方才能正常解密。这个传递就会用到对方的公钥。例如一开始客户端用服务端公钥加密自己的会话秘钥和公钥传递给服务端，以及后来服务端再用客户端的公钥加密自己的会话秘钥传回客户端。
3. 有了对方的会话秘钥之后，对方传过来的用它自己的会话秘钥加密的信息，就可以用同样的秘钥来解密，这就是对称算法。
4. 非对称算法只作用于一开始建立通讯时，互相传递秘钥时所用。（即一开始的公钥和私钥）

补充：
常见对称加密算法： DES, AES, 3DES。优点是计算效率高。
常见非对称加密算法： RSA, ECC。优点是更加安全，因为只需要交换公钥即可，私钥不需要交换。

所以为了解决对称加密算法中私钥交换的缺陷，使用非对称加密来交换私钥，之后再使用对称加密来通信这样的混合使用模式是最常见的，也是 HTTPS 的模式。

## CSRF

核心是攻击者利用正常人的身份发送请求，骗过服务器执行一些操作，如发邮件，转账，购买商品等。

大体模式如下：

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问网站A；

5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

一个更实际的例子：

受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。

黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。

这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： `src="http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory"`，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。

目前防御 CSRF 攻击主要有三种策略：

1. 验证 HTTP Referer 字段；

    这个方法的实现难度非常低，只要在所有请求添加一个拦截器进行验证即可。但问题是，客户端请求是可以伪造的，referrer 也是可以修改的。此外现代浏览器会有“禁止传递 referrer”的选项（为了隐私）。因此这种方式并不能彻底防止 CSRF

2. 在请求地址中添加 token 并验证；

    CSRF攻击能够成功，重点在于所有需要的信息都在 cookie 中（登录验证信息）。如果添加一些不在 cookie 中的必要信息，那么攻击就会失效。

    添加token的难点有两个。第一需要在所有请求中都增加 token 参数，不能遗漏。第二是难以保证 token 的安全，例如从 referrer 中获取 token 等等。

3. 在 HTTP 头中自定义属性并验证。

    这种方式实际就是把 token 从参数移动到 HTTP 头中。

## XSS

XSS 的分类：

1. 反射型。即相信用户的输入，直接输出到页面导致 JS 脚本执行
2. 存储型。指输入的内容直接存入数据库。这样以后只要取出并展现这条数据时就会执行 JS。

解决方案：

1. 转义
    1. HTML 实体 (`&lt;` `&gt;` `&amp;` `&quot;`)。用在 HTML 或者属性中输出内容时。
    2. JS Encode (`\\r`, `\\n`, `\u1234` 等)，用于在 JS 或者事件或者 CSS 中输出内容时
    3. URIComponent (`%12`)，用于在 URL 上输出内容时

2. 将重要的 cookie 设置为 http-only
3. 将表单项内容的类型进行限制，如只能填写数字，只能填写某些字符等。
4. 如果有用户输入作为 HTML 直接输出到页面的，需要过滤敏感标签，如 `<script>`， `<iframe>` 等


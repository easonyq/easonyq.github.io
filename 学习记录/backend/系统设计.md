# 系统设计

## 前后端架构概览

```
前端 (HTML CSS JS)

    HTTP / web socket

Nginx / Load Balance

    HTTP

Web Server (nodejs, Java, PHP)

    RPC / SOA

Application Server (MQ, 区分PC/Mobile)

    REDIS

DB / ES / Deamon
```

## DB

CAP原则：任何DB至多只能满足CAP的其中之二。

C：一致性
A：**待补充**
P：分布可用性

### RDB

以 MySQL 为代表的传统 DB，业界大规模使用。需要注意的概念是

1. 分表

    当一个表很大了之后，需要分拆。分拆原则有很多，最简单的是平均分配，比如取模，分段等等，各有优劣。

    还有一种分发叫做纵向分割，即一条记录某几列在这个表，某几列在另外一个表。刚才那种叫横向分表，比较常用。

2. 分库

    虽然分表能解决容量过大影响性能的问题，但不能解决吞吐量的问题，因为吞吐量限制是以数据库为单位，而不是以表为单位。

    例如一个库有10张表，如果只想针对用户表进行吞吐量的提升，可以牺牲其他9张表的吞吐量，这实际是做不到的。

    那么解决方案就是把用户表单独成一个库。

### NoSQL

以 Mongo 为代表，它的优势是没有固定的 schema，因此可以比较灵活的存取。

比较新的叫 CouchDB。

**待补充**

### 列式存储

以 HBase 为代表。

**待补充**

### New SQL

Cassander， LSM算法

**待补充**

### 缓存

Redis

**待补充**

## ES

Elastic Search，可以理解为后端的搜索引擎，主要用于搜索日志。

基于 field，通过倒排查询到数据。

正排：原始表结构，以 id 作为主键。

倒排：是`索引`的别称，指按照某一列（非 id）进行分类，这样可以在按照这一列搜索的时候快速定位，缩小搜索范围。

举例来说，一个学生表，有 id, name, age 等列。如果我们为 age 建立索引（也称 age 的倒排），则数据库会记录按照 age 进行分类。例如 age = 20 的，有哪几个学生；age = 21 的，有哪几个学生等等。也可能不是按照相等，而是按照范围，例如 `age < 20 && age > 10` 的归为一类。这些额外的数据可以存在其他数据库，也可以存在 redis。搜索时首先从索引开始搜索。

主库（正排）和索引需要做同步。可以每次更新都触发，也可以定时更新。

1. 每次更新都触发的话，在添加数据的时候，需要同时去更新索引。在修改数据的时候，如果修改的是有索引的列，也需要更新索引。这两种操作都是先更新主库，再同步到索引。但删除是先删除索引，再同步主库，这是因为搜索是从索引开始的，只要删除了索引，即便主库还有记录，也不会被搜索，已经满足用户的需求了。

2. 如果是定期更新，则任何写操作都在主库上进行，隔一定时间（例如一天）全量更新索引。这种对于时效性要求不高，避免了触发更新时候的并发问题。

## Deamon

一些守护进程，多用于定期清理业务数据，删除日志，推送数据等。是 Application Server 的一部分，但逻辑上可以独立。

## 消息队列 (MQ)

假设A调用B，同步调用方式下，A调用B的API（多用RPC或者HTTP），B同步返回。

如果想使用异步方式提升效率，那么A必须给B留一个回调API，这样B完成后，通过API返回结果。这个类似于前端回调。不过这样会导致A和B互相依赖。

更好的方式是构造一个消息中间层（集群），收集A的调用信息，调用B后再把结果返回给A，解开了A和B的依赖关系，同时也可以支持服务的添加和删除。

Kafka 是实现消息队列的常用架构。

**待补充**

## 前端

mobx

## 其他内容

* CRDT [参考](https://yq.aliyun.com/articles/635632?utm_content=m_1000015503)

    一种专门的数据结构，用于保证分布式系统的最终一致性，即经过一定时间后最终各个节点的状态是一致的。它还分为两种：op-based CRDT 和 state-based CRDT。

    op-based CRDT 指操作满足交换律，结合律和幂等律。这样的操作可以直接应用到别的节点，只要保证每个节点都被应用了所有的操作，最终状态一定是一致的。

    state-based CRDT 指操作不满足以上定律，额外构造一个单调增的状态来辅助同步（也叫偏序关系），例如时间戳，版本号等都是常用的。

    已有的 CRDT 有 Counter, Register, Set 等，可参考上面的链接。

* 线程安全，乐观锁和 CAS [参考]（https://blog.csdn.net/qq_35571554/article/details/82892806)

    线程安全：多线程程序中，如果多个线程访问一个共享变量，且没有锁的机制，那么最终的计算结果可能是错误的，且不可预料。例如两个线程同时进行 `counter++` 的操作 100 次（ `counter` 初始值为0），但最终结果可能小于 200。这是因为 `counter++` 并不是原子操作，分为获取值，增加和写入三步。如果在线程 A 的获取和增加之间，线程 B 插入也进行获取，就可能导致最终少加一次。这种情况的出现不可预料，就会导致结果小于 200。

    乐观锁 & 悲观锁：悲观锁指的是悲观的认定某些操作必然会冲突，所以在这些操作的时候排他，阻止其他线程获取共享变量。这样能保证程序的结果正确，但性能差一些。`syncornized` 就是悲观锁。乐观锁与之相反，认为先不考虑引发冲突，等冲突了再重新执行一遍即可。

    CAS：Compare and Swap(也有叫 Set)，CAS机制当中使用了3个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。如果比较失败，会阻止当次提交，之后重新执行。所以 CAS 是一种乐观锁的实现。Java 的 Atomic 系列类和 Lock 系列类，都使用了 CAS。

    CAS 的问题主要有三个：

    1. 当并发量很大的时候，许多线程反复尝试一直不成功，给 CPU 带来很大的压力（性能可能还不如悲观锁）；
    2. CAS 保证的是一个变量的原子操作，不保证代码块的原子性。例如要保证多个变量共同的原子性，就必须使用悲观锁。（取巧的办法是把多个变量变成一个，例如 Java 的 AtomicReference）
    3. ABA问题。(可引入单调增的属性来规避，例如时间戳，版本号等)

# JS 类型转换

## 类型

JS 中的类型总计有以下几种：

* 数值 Number
* 布尔 Boolean
* 字符串 String
* 对象 Object 这里面包括很多种子类，例如 Date, Array 等。
* 方法 Function
* 特殊 `null` 和 `undefined`

## 显式转换

### Number(mix) - 转换成数值

1. 如果是布尔值，`true` 和 `false` 分别被转换为 `1` 和 `0`
2. 如果是数字值，返回本身。这里注意如果是 `0` 开头，就当成八进制解析；如果是 `0x` 开头，就当成十六进制解析。
3. 如果是 `null`，返回 `0`.
4. 如果是 `undefined`，返回 `NaN`。
5. 如果是字符串，遵循以下规则：
    1. 如果字符串中只包含数字，则将其转换为十进制（忽略前导的 `0`）
    2. 如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导的 `0`）
    3. 如果是空字符串，将其转换为 `0`
    4. 如果字符串中包含非以上格式，则将其转换为 `NaN`
6. 如果是对象，则调用对象的 `valueOf()` 方法，然后依据前面的规则转换返回的值。如果转换的结果是 `NaN`，则调用对象的 `toString()` 方法，再次依照前面的规则转换返回的字符串值。

针对第 6 点，对象的 `valueOf()` 的结果如下：

|对象|返回值|
|Array|数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 `Array.toString` 和 `Array.join` 方法相同|
|Boolean|Boolean 值|
|Date|存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC|
|Function|函数本身|
|Number|数字值|
|Object|对象本身。这是默认情况|
|String|字符串值|

一些需要重点记住的（或者说常出现在题目里的）有：

```javascript
Number(null) === Number(false) === Number('') === Number([]) === Number([0]) === 0
Number(undefined) === NaN
Number(070) === 56
Number('070') === 70
```

### parseInt(string, radix) - 转换成数值

1. 忽略字符串前面的空格，直至找到第一个非空字符
2. 如果第一个字符不是数字符号或者负号，返回 `NaN`
3. 如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止
4. 如果上步解析的结果以 `0` 开头，则将其当作八进制来解析；如果以 `0x` 开头，则将其当作十六进制来解析
5. 如果指定 `radix` 参数，则以 `radix` 为基数进行解析

这里最需要注意的点是：
1. 平时写代码**一定**要把第二个参数写上，绝大部分情况是 `10`，不要省略。
2. 面试题多数会把第二个参数省略。这时候就要注意上述规则的第 4 条。

一些重点如下：

```javascript
parseInt(070) === 56 // 当成8进制了
parseInt('070') === 70 // 以字符串形式不会被当成8进制
```

### parseFloat(string) - 转换成数值

和 `parseInt` 基本类似，主要差别有：

1. 它没有第二个参数，或者可以理解成固定为 `10`。
2. 如果输入是以 `.` 开头（后接数字），在 `parseInt` 会被解析成 `NaN`，而 `parseFloat` 会解析成小数，是有效的。
3. 如果输入是整数（或者整数的字符串），解析结果也是整数，不会是浮点数。

```javascript
parseFloat('.1') === 0.1
parseFloat('10') === parseFloat(10) === 10 // 而不是 10.0 或者其他值
```

### toString() - 转换成字符串

除了 `undefined` 和 `null` 之外，其他类型都有 `toString()` 方法。它总返回一个字符串。

|对象|操作|
|Array|将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。|
|Boolean|如果 Boolean 值是 `true`，则返回 `'true'`。否则，返回 `'false'`。|
|Date|返回日期的文字表示法。|
|Error|返回一个包含相关错误信息的字符串。|
|Function|返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：`function functionname() { [native code] }`|
|Number|返回数字的文字表示。|
|String|返回 String 对象的值。|
|默认|返回 `'[object objectname]'`，其中 objectname 是对象类型的名称。|

这里常见的题目同样是空数组：

```javascript
[].toString() === ''
```

### String(mix) - 转换成字符串

1. 如果有 `toString()` 方法，则调用该方法并返回结果
2. 如果是 `null`，返回 `'null'`
3. 如果是 `undefined`，返回 `'undefined'`

所以这里主体和 `toString()` 是一致的，只是补充了 `undefined` 和 `null` 两种情况。

### Boolean(mix) - 转换成布尔值

以下值会被转换为 `false`：
* `false`
* `''`
* `0`
* `NaN`
* `null`
* `undefined`

其余任何值都会被转换为 `true`，包括 `Boolean([])`。

## 隐式转换

**隐式转换是面试题最最常见的套路**。在 JS 碰到以下几种情况时，内核会尝试进行隐式转换。

### isNaN(mix) - 先转换数值，再判断结果

`isNaN()` 函数会尝试将参数值用 `Number()` 进行转换，如果结果为“非数值”则返回 `true`，否则返回 `false`。所以它可以用来检测字符串等非数值类型，例如：

```javascript
isNaN('1') === isNaN(true) === isNaN(false) === isNaN(null) === isNaN([]) === false
isNaN(undefined) === true
NaN !== NaN // 补充一条：NaN === NaN 返回的是 false，利用这个特性外加 typeof NaN === 'number'，可以判断 NaN。
```

所以这里的重点在于 `Number()` 的返回值。

### 递增递减操作符（包括前置和后置）、一元正负符号操作符 - 也是转换为数值的一种方式

这些操作符适用于任何数据类型的值，针对不同类型的值，该操作符遵循以下规则：
1. 如果是包含有效数字字符的字符串，先将其转换为数字值（转换规则同 `Number()`），在执行加减 1 的操作，字符串变量变为数值变量。
2. 如果是不包含有效数字字符的字符串，将变量的值设置为 `NaN`，字符串变量变成数值变量。
3. 如果是布尔值 `false`，先将其转换为 `0`再执行加减 1 的操作，布尔值变量编程数值变量。
4. 如果是布尔值 `true`，先将其转换为 `1` 再执行加减 1 的操作，布尔值变量变成数值变量。
5. 如果是浮点数值，执行加减 1 的操作。
6. 如果是对象，先调用对象的 `valueOf()` 方法，然后对该返回值应用前面的规则。如果结果是 `NaN`，则调用 `toString()`方法后再应用前面的规则。对象变量变成数值变量。

经过对比发现，其规则与 `Number()` 规则基本相同，所以重点还是 `Number()`。一些有代表性的例子：

```javascript
+new Date() // 等同于 Date.now()，比较常见于代码
+'1' === +true === 1
+[] === +'' === +false === -false === 0 // 单纯输出 -false 会打印出 -0， 但它和 0 也是相等的
+'true' === NaN // 因为 Number('true') === NaN
```

### 加法运算操作符 - 可当加法，也可当拼接，偏向字符串拼接。

加号运算操作符在 JS 也用于字符串连接符，所以加号操作符的规则分两种情况：

1. 如果两个操作值都是数值，其规则为：
    1. 如果一个操作数为 `NaN`，则结果为 `NaN`
    2. 如果是 `Infinity+Infinity`，结果是 `Infinity`
    3. 如果是 `-Infinity+(-Infinity)`，结果是 `-Infinity`
    4. 如果是 `Infinity+(-Infinity)`，结果是 `NaN`
    5. 如果是 `+0+(+0)`，结果为 `+0`
    6. 如果是 `(-0)+(-0)`，结果为 `-0`
    7. 如果是 `(+0)+(-0)`，结果为 `+0`
2. 如果两个操作值都是字符串，则将它们拼接起来 (常见的字符串拼接操作)
3. 如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来
4. 如果一个操作数是对象、数值或者布尔值，则调用 `toString()` 方法取得字符串值，然后再应用前面的字符串规则。对于 `undefined` 和 `null`，分别调用 `String()` 显式转换为字符串。

可以看出，如果两边都是数值，就当加法用，结果也是数值。而只要有一边不是数值，就当字符串操作，两边都转换为字符串然后拼接。一些例子如下：

```javascript
'1' + 2 === 1 + [2] === '12'
1 + [] === '1' + [] === '1'
```

其他的数学操作符，例如减号，乘号，取模等，因为他们不存在加号“拼接字符串”的功能，所以内部是**转化为数值并进行计算的**，例如：

```javascript
1 - [1] === '' - [] === false * null === 0 // 这些都是先尝试用 Number 的方式转化为数值，再进行运算。
```

### 关系操作符（<, >, <=, >=） - 不强求类型，但偏向数值比较。

这些操作符并不要求必须转化为数值，因此需要分情况讨论，必要时系统也会进行隐式类型转换：

1. 如果两个操作值都是数值，则进行数值比较
2. 如果两个操作值都是字符串，则比较字符串对应的字符编码值 （逐个比较，直到比出大小。如果一边长度用完了，则认为是较小的一方）
3. 如果只有一个操作值是数值，则**将另一个操作值转换为数值，进行数值比较**
4. 如果一个操作数是对象，则调用 `valueOf()` 方法（如果对象没有 `valueOf()` 方法则调用 `toString()` 方法），得到的结果按照前面的规则执行比较
5. 如果一个操作值是布尔值，则将其转换为数值，再进行比较

几个注意点：

1. 只要有一边是数值，就会把两边都转化为数值进行比较。可以理解为比较还是偏向数值的。
2. `NaN` 是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回 `false`。

```javascript
'a' < 'b'
'aa' < 'ab'
'aa' < 'aaa'
NaN < 0 // false
NaN > 0 // false
```

### 相等操作符（==） - 重点在最后，面试必考题

相等操作符会对操作值进行隐式转换后进行比较：

1. 如果一个操作值为布尔值，则在比较之前先将其转换为数值
2. 如果一个操作值为字符串，另一个操作值为数值，则通过 `Number()` 函数将字符串转换为数值
3. 如果一个操作值是对象，另一个不是，则调用对象的 `valueOf()` 方法，得到的结果按照前面的规则进行比较
4. `null` 与 `undefined` 是相等的
5. 如果一个操作值为 `NaN`，则相等比较返回 `false`
6. 如果两个操作值都是对象，则比较它们是不是指向同一个对象

这里是面试的重中之重。从上述规则可以看出，双等号也是偏向于数值比较的（除非两边都是对象），大多是先转化为数值再进行比较。一些常见的题目如下：

```javascript
null == undefined
[] == '' == 0
![] == 0 // [] 变成布尔值是 true，这是引发奇特等式的核心点。
[] == ![] // 两个结果都是 0，所以相等
[0] == 0
[0] == [] // false 这两边都是对象，就不转化了，比较的内容变成是否是相同的引用了，如上第6条
{} == {} // false 如上第6条
```
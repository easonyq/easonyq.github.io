# 数组相关的算法题

## 找出第 k 大的数 （快速排序）

题目：在一个数组中找出第 k 大的数
举例：[1,3,2,6,5,10,8] 中第 4 大的数为5

思路：

findElement(arr, k, start, end)。
对数组进行快排，选第一个元素为目标，比它大的放在右边，小的放在左边。记录交换之后目标元素的位置，设为 i。
如果 end - i = k - 1，表示目标元素之后的元素数量等于 k - 1，那么目标就是结果，返回 a[i]。
如果 end - i > k - 1，表示目标元素之后的元素数量大于 k - 1，那么结果在右边，继续查找 findElement(arr, k, i + 1, end)
如果 end - i < k - 1，表示目标元素之后的元素数量大于 k - 1，那么结果在左边，继续查找 findElement(arr, k - (end - i + 1), start, i - 1)

最终结果是计算 findElement(arr, k, 0, arr.length - 1)

## 最大连续子串的和 （动态规划）

题目：一个数组中包含正数和负数。求一个 __连续的__ 子串，和相加最大。
举例：[1,-2,3,10,-4,12]，得到 [3,10,-4,12] 为最大连续子串。

思路：

设 Dp[i] 等于 __包含 a[i] 的__ 下标从 0 到 i - 1 之间的子数组内的最大连续子串的和。因此有

Dp[i] = max(Dp[i - 1] + a[i], a[i]) (i > 0)

另外初始值 Dp[0] = 0

所有 Dp 计算完成之后，找出 Dp 数组中最大的元素，即为结果。

补充：Dp[i] 只考虑包含 a[i - 1] 的情况，因为不包含 a[i - 1] 的情况已经在 i 更小的时候考虑过了。

## 最长连续回文子串的长度 （动态规划）

题目：找出一个数组中包含的最长的对称 __连续__ 子串的长度。
举例：abcdcbxy 中，bcdcb 是最长的回文子串，长度为 5。

思路：

假设 Dp[i, j] 表示从 a[i] 到 a[j] 组成的子数组是否为回文子串。是就取值为 true，否则 false。因此有

Dp[i, j] = Dp[i + 1, j - 1] (如果 a[i] = a[j])
Dp[i, j] = false (如果 a[i] != a[j])

另外初始值 Dp[i, i] = true, Dp[i, i + 1] = a[i] === a[i + 1]

所有 Dp 计算完成之后，找到 Dp 里为 true 的元素中 j - i 最大的值即为结果。

补充：可以发现 Dp[i, j] 是由 Dp[i + 1, j - 1]计算而来，因此不能简单让 i 和 j 都从 0 开始循环，而是从中间 (i = j) 向两边计算。

要实现从中间向两边计算，可以采用如下方法：
```javascript
for (let gap = 0; gap < a.length; gap++) {
    for (let i = 0; i + gap < a.length; i++) {
        // HERE
    }
}
```

## 最长公共子序列的长度 （动态规划）

题目：找出两个数组中共同包含的最长的公共子序列。序列不一定是连续的，只要顺序一致即可。
举例：[1, 2, 3, 4, 5, 6] 和 [1, 3, 5, 7] 的最长公共子序列为 [1, 3, 5]

思路：

假设 Dp[i, j] 表示 a[0] 到 a[i - 1]，b[0] 到 b[j - 1] 两个子数组中最长公共子序列的长度。因此有

Dp[i, j] = Dp[i - 1, j - 1] + 1 (如果 a[i - 1] = b[j - 1])
Dp[i, j] = max(Dp[i - 1, j], Dp[i, j - 1]) (如果 a[i - 1] != b[j - 1])

初始值： Dp[0, j] = Dp[i, 0] = 0 (i 或者 j 有一个为0的时候，其实是个空串，因此结果为0)

补充：这里要注意下标的 - 1 处理。例如 Dp[2, 3] 表示 a 取 2 个数字(a[0], a[1])， b 取 3 个数字(b[0], b[1], b[2])进行比较。因此实际上计算下标的时候要 - 1。

## 最长递增子序列的长度 （动态规划）

题目：找出一个数组中包含的最长的递增子序列。序列可以不连续。
举例： [3, 2, 10, 5, 11, 8, 7] 的结果是 [2, 5, 8] （结果不唯一）

思路：

假设 Dp[i] 表示 a[0] 到 a[i] 的子数组中包含 a[i] 的最长递增子序列的长度。因此有

Dp[i] = max(遍历 k 从 0 到 i - 1，当 a[i] > a[k] 时返回 Dp[k]，否则返回 0) + 1

因为纳入了 a[i]，因此等于所有能和 a[i] 组成递增子序列的之前计算过的序列长度 + 1

初始值 Dp[0] = 1

最后遍历所有的 Dp 找出最大值即可。

## 最长回文子序列的长度 （动态规划）

题目：找出一个数组中包含的最长的回文子序列的长度。序列可以不连续。
举例： awchbcklaui 的结果是 acbca，因此是5

思路：

设 Dp[i, j] 表示 a[i] 到 a[j] 构成的子数组中最长回文子序列的长度。因此有

Dp[i, j] = Dp[i + 1, j - 1] + 2 (如果 a[i] = a[j])
Dp[i, j] = max(Dp[i + 1, j], Dp[i, j - 1]) (如果 a[i] != a[j])

初始值 Dp[i, i] = 1, Dp[i, i + 1] = (a[i] === a[i + 1] ? 2 : 1)

最终需要计算 Dp[0, a.length - 1]。也是从中间往两边计算，也可以参考使用 gap 进行循环。

## 回文子序列的个数（动态规划）

题目：找出一个数组中包含的所有回文子序列的个数。

思路：

设 Dp[i, j] 表示 a[i] 到 a[j] 构成的子数组中的回文子序列个数。因此有

Dp[i, j] = Dp[i + 1, j] + Dp[i, j - 1] - Dp[i + 1, j - 1] (如果 a[i] != a[j])
Dp[i, j] = Dp[i + 1, j] + Dp[i, j - 1] - Dp[i + 1, j - 1] + Dp[i + 1, j - 1] + 1 (如果 a[i] = a[j])

补充：a[i] = a[j] 时多出来的 (Dp[i + 1, j - 1] + 1) 含义分别如下：
1. 因为 a[i] = a[j]，因此原先 a[i + 1] 到 a[j - 1] 之间的回文子序列加上 a[i], a[j] 都能构成新的回文子序列
2. 而 a[i] 和 a[j] 两者本身也能构成一个新的回文子序列，因此 + 1。

最终计算 Dp[0, a.length - 1]

## 从数组中找出只出现一次的元素 （经典题，异或）

题目：给定一个整数数组，除了某个元素外其余元素均出现两次。请找出这个只出现一次的元素。

备注：你的算法应该是一个线性时间复杂度。 你可以不用额外空间来实现它吗？

思路：异或 A ^ B

异或的几个定律：

1.恒定律：A ^ 0 = A
2.归零率：A ^ A = 0
3.交换律：A ^ B = B ^ A
4.结合律：(A ^ B) ^ C = A ^ (B ^ C)

**经典面试题：不使用额外空间交换两个数字**

a = a ^ b
b = a ^ b (说明：a ^ b ^ b = a ^ 0 = a)
a = a ^ b (说明：a ^ b ^ a = b ^ 0 = b)

用加减法也能实现

a = a + b
b = a - b
a = a - b

回到题目，利用交换律和归零率，容易得出：**把所有数字都异或，相同的会变成0，而落单的会留下来。**所以结果就是落单的元素。

## 寻找众数 （经典题）

题目：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

备注：你可以假设数组是非空的，并且给定的数组总是存在众数。

思路：核心在一个结论：**删除数组中两个不同的数，该数组的众数不变**

如果这两个数都不是众数，那删除肯定不影响。

如果这两个数有一个是众数，那删除之后，数组大小为 n-2，而众数的数量大于 ⌊ n/2 ⌋ - 1 = ⌊ (n-2)/2 ⌋，因此它依然是众数。

因此，尝试这样不断删除，直到扫描到数组末尾之后，数组中剩下的元素应该全部都是一样的，也就是众数本身。

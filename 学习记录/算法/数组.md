# 数组相关的算法题

## 找出第 k 大的数 （快速排序）

题目：在一个数组中找出第 k 大的数
举例：[1,3,2,6,5,10,8] 中第 4 大的数为5

思路：

findElement(arr, k, start, end)。
对数组进行快排，选第一个元素为目标，比它大的放在右边，小的放在左边。记录交换之后目标元素的位置，设为 i。
如果 end - i = k - 1，表示目标元素之后的元素数量等于 k - 1，那么目标就是结果，返回 a[i]。
如果 end - i > k - 1，表示目标元素之后的元素数量大于 k - 1，那么结果在右边，继续查找 findElement(arr, k, i + 1, end)
如果 end - i < k - 1，表示目标元素之后的元素数量大于 k - 1，那么结果在左边，继续查找 findElement(arr, k - (end - i + 1), start, i - 1)

最终结果是计算 findElement(arr, k, 0, arr.length - 1)

## 最大连续子串的和 （动态规划）

题目：一个数组中包含正数和负数。求一个 __连续的__ 子串，和相加最大。
举例：[1,-2,3,10,-4,12]，得到 [3,10,-4,12] 为最大连续子串。

思路：

设 Dp[i] 等于 __包含 a[i] 的__ 下标从 0 到 i - 1 之间的子数组内的最大连续子串的和。因此有

Dp[i] = max(Dp[i - 1] + a[i], a[i]) (i > 0)

另外初始值 Dp[0] = 0

所有 Dp 计算完成之后，找出 Dp 数组中最大的元素，即为结果。

补充：Dp[i] 只考虑包含 a[i - 1] 的情况，因为不包含 a[i - 1] 的情况已经在 i 更小的时候考虑过了。

## 最长公共子序列的长度 （动态规划）

题目：找出两个数组中共同包含的最长的公共子序列。序列不一定是连续的，只要顺序一致即可。
举例：[1, 2, 3, 4, 5, 6] 和 [1, 3, 5, 7] 的最长公共子序列为 [1, 3, 5]

思路：

假设 Dp[i, j] 表示 a[0] 到 a[i - 1]，b[0] 到 b[j - 1] 两个子数组中最长公共子序列的长度。因此有

Dp[i, j] = Dp[i - 1, j - 1] + 1 (如果 a[i - 1] = b[j - 1])
Dp[i, j] = max(Dp[i - 1, j], Dp[i, j - 1]) (如果 a[i - 1] != b[j - 1])

初始值： Dp[0, j] = Dp[i, 0] = 0 (i 或者 j 有一个为0的时候，其实是个空串，因此结果为0)

补充：这里要注意下标的 - 1 处理。例如 Dp[2, 3] 表示 a 取 2 个数字(a[0], a[1])， b 取 3 个数字(b[0], b[1], b[2])进行比较。因此实际上计算下标的时候要 - 1。

## 最长递增子序列的长度 （动态规划）

题目：找出一个数组中包含的最长的递增子序列。序列可以不连续。
举例： [3, 2, 10, 5, 11, 8, 7] 的结果是 [2, 5, 8] （结果不唯一）

思路：

假设 Dp[i] 表示 a[0] 到 a[i] 的子数组中包含 a[i] 的最长递增子序列的长度。因此有

Dp[i] = max(遍历 k 从 0 到 i - 1，当 a[i] > a[k] 时返回 Dp[k]，否则返回 0) + 1

因为纳入了 a[i]，因此等于所有能和 a[i] 组成递增子序列的之前计算过的序列长度 + 1

初始值 Dp[0] = 1

最后遍历所有的 Dp 找出最大值即可。

## 寻找众数

题目：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

备注：你可以假设数组是非空的，并且给定的数组总是存在众数。

思路：核心在一个结论：**删除数组中两个不同的数，该数组的众数不变**

如果这两个数都不是众数，那删除肯定不影响。

如果这两个数有一个是众数，那删除之后，数组大小为 n-2，而众数的数量大于 ⌊ n/2 ⌋ - 1 = ⌊ (n-2)/2 ⌋，因此它依然是众数。

因此，尝试这样不断删除，直到扫描到数组末尾之后，数组中剩下的元素应该全部都是一样的，也就是众数本身。

代码实现细节：
1. 需要递归。每次递归的操作是扫一遍数组，把不同的对去掉。能保证扫完后众数不变，但不表示扫一次就够。
2. 当数组只剩下1个元素，或者数组每个元素都相等时，它就是众数。

## 旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释:
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

**思路**：
1. 先处理k（标准化），使得它对长度取模，再处理负数的情况，让k的范围在 [0, n] 之间。(0和n都可以直接return)
2. 把数组分成两段。前半段是n-k个，后半段是k个。
3. 把两个数组分别颠倒，最后再把整个数组颠倒

也有其他解法：
1. 每个元素的最终位置其实可以计算得知。那么可以新建一个临时变量，然后从第一个元素开始，把目标位置的值存到临时变量，然后写入。（[1,2,3,1,5,6,7], temp=4）
2. 再计算4应该去的位置，把那个位置的数字和temp交换
3. 执行 n 次即可
# 数组相关的算法题

## 找出第 k 大的数 （快速排序）

题目：在一个数组中找出第 k 大的数
举例：[1,3,2,6,5,10,8] 中第 4 大的数为5

思路：

findElement(arr, k, start, end)。
对数组进行快排，选第一个元素为目标，比它大的放在右边，小的放在左边。记录交换之后目标元素的位置，设为 i。
如果 end - i = k - 1，表示目标元素之后的元素数量等于 k - 1，那么目标就是结果，返回 a[i]。
如果 end - i > k - 1，表示目标元素之后的元素数量大于 k - 1，那么结果在右边，继续查找 findElement(arr, k, i + 1, end)
如果 end - i < k - 1，表示目标元素之后的元素数量大于 k - 1，那么结果在左边，继续查找 findElement(arr, k - (end - i + 1), start, i - 1)

最终结果是计算 findElement(arr, k, 0, arr.length - 1)

## 最大连续子串的和 （动态规划）

题目：一个数组中包含正数和负数。求一个 __连续的__ 子串，和相加最大。
举例：[1,-2,3,10,-4,12]，得到 [3,10,-4,12] 为最大连续子串。

思路：

设 Dp[i] 等于 __包含 a[i] 的__ 下标从 0 到 i - 1 之间的子数组内的最大连续子串的和。因此有

Dp[i] = max(Dp[i - 1] + a[i], a[i]) (i > 0)

另外初始值 Dp[0] = 0

所有 Dp 计算完成之后，找出 Dp 数组中最大的元素，即为结果。

补充：Dp[i] 只考虑包含 a[i - 1] 的情况，因为不包含 a[i - 1] 的情况已经在 i 更小的时候考虑过了。

## 最长公共子序列的长度 （动态规划）

题目：找出两个数组中共同包含的最长的公共子序列。序列不一定是连续的，只要顺序一致即可。
举例：[1, 2, 3, 4, 5, 6] 和 [1, 3, 5, 7] 的最长公共子序列为 [1, 3, 5]

思路：

假设 Dp[i, j] 表示 a[0] 到 a[i - 1]，b[0] 到 b[j - 1] 两个子数组中最长公共子序列的长度。因此有

Dp[i, j] = Dp[i - 1, j - 1] + 1 (如果 a[i - 1] = b[j - 1])
Dp[i, j] = max(Dp[i - 1, j], Dp[i, j - 1]) (如果 a[i - 1] != b[j - 1])

初始值： Dp[0, j] = Dp[i, 0] = 0 (i 或者 j 有一个为0的时候，其实是个空串，因此结果为0)

补充：这里要注意下标的 - 1 处理。例如 Dp[2, 3] 表示 a 取 2 个数字(a[0], a[1])， b 取 3 个数字(b[0], b[1], b[2])进行比较。因此实际上计算下标的时候要 - 1。

## 最长递增子序列的长度 （动态规划）

题目：找出一个数组中包含的最长的递增子序列。序列可以不连续。
举例： [3, 2, 10, 5, 11, 8, 7] 的结果是 [2, 5, 8] （结果不唯一）

思路：

假设 Dp[i] 表示 a[0] 到 a[i] 的子数组中包含 a[i] 的最长递增子序列的长度。因此有

Dp[i] = max(遍历 k 从 0 到 i - 1，当 a[i] > a[k] 时返回 Dp[k]，否则返回 0) + 1

因为纳入了 a[i]，因此等于所有能和 a[i] 组成递增子序列的之前计算过的序列长度 + 1

初始值 Dp[0] = 1

最后遍历所有的 Dp 找出最大值即可。

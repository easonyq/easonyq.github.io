# 字符串面试题

## 最长连续回文子串的长度 （动态规划）

题目：找出一个字符串中包含的最长的对称 __连续__ 子串的长度。
举例：abcdcbxy 中，bcdcb 是最长的回文子串，长度为 5。

思路：

假设 Dp[i, j] 表示从 a[i] 到 a[j] 组成的子数组是否为回文子串。是就取值为 true，否则 false。因此有

Dp[i, j] = Dp[i + 1, j - 1] (如果 a[i] = a[j])
Dp[i, j] = false (如果 a[i] != a[j])

另外初始值 Dp[i, i] = true, Dp[i, i + 1] = a[i] === a[i + 1]

所有 Dp 计算完成之后，找到 Dp 里为 true 的元素中 j - i 最大的值即为结果。

补充：可以发现 Dp[i, j] 是由 Dp[i + 1, j - 1]计算而来，因此不能简单让 i 和 j 都从 0 开始循环，而是从中间 (i = j) 向两边计算。

要实现从中间向两边计算，可以采用如下方法：
```javascript
for (let gap = 0; gap < a.length; gap++) {
    for (let i = 0; i + gap < a.length; i++) {
        // HERE
    }
}
```

## 最长回文子序列的长度 （动态规划）

题目：找出一个数组中包含的最长的回文子序列的长度。序列可以不连续。
举例： awchbcklaui 的结果是 acbca，因此是5

思路：

设 Dp[i, j] 表示 a[i] 到 a[j] 构成的子数组中最长回文子序列的长度。因此有

Dp[i, j] = Dp[i + 1, j - 1] + 2 (如果 a[i] = a[j])
Dp[i, j] = max(Dp[i + 1, j], Dp[i, j - 1]) (如果 a[i] != a[j])

初始值 Dp[i, i] = 1, Dp[i, i + 1] = (a[i] === a[i + 1] ? 2 : 1)

最终需要计算 Dp[0, a.length - 1]。也是从中间往两边计算，也可以参考使用 gap 进行循环。

## 回文子序列的个数（动态规划）

题目：找出一个数组中包含的所有回文子序列的个数。

思路：

设 Dp[i, j] 表示 a[i] 到 a[j] 构成的子数组中的回文子序列个数。因此有

Dp[i, j] = Dp[i + 1, j] + Dp[i, j - 1] - Dp[i + 1, j - 1] (如果 a[i] != a[j])
Dp[i, j] = Dp[i + 1, j] + Dp[i, j - 1] - Dp[i + 1, j - 1] + Dp[i + 1, j - 1] + 1 (如果 a[i] = a[j])

补充：a[i] = a[j] 时多出来的 (Dp[i + 1, j - 1] + 1) 含义分别如下：
1. 因为 a[i] = a[j]，因此原先 a[i + 1] 到 a[j - 1] 之间的回文子序列加上 a[i], a[j] 都能构成新的回文子序列
2. 而 a[i] 和 a[j] 两者本身也能构成一个新的回文子序列，因此 + 1。

最终计算 Dp[0, a.length - 1]

## 字符串的排列

给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

示例1:

输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").


示例2:

输入: s1= "ab" s2 = "eidboaoo"
输出: False


注意：

输入的字符串只包含小写字母
两个字符串的长度都在 [1, 10,000] 之间

思路：

首先明确，要比较的仅是s1和s2**的子串**，所以两者长度必然相等才可能为true，因此可在 s2 上使用滑动窗口。

一个朴素的做法是使用 i, j，每次截取s2的一段，与s1进行比较，直到最后。这个做法的弱点在于每次窗口滑动都得重新计算。

改进方案是每次滑动只要计算变化值，而不需重新计算。具体来说，当往后滑动一位时，需要添加新加入的字符，而去掉滑出去的字符即可。这样就不用反复计算。